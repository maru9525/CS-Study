# Operatin System(운영체제)

## 프로세스와 스레드

- 프로그램 : 파일 단위로 저장 장치에 저장되어 있으며, 아직 실행되지 않은 상태의 코드 덩어리를 의미한다.
- 프로세스 : 실행 중인 프로그램이다. 프로그램을 실행하기 위해서는 주소 공간, 파일, 메모리 등이 필요한데 운영체제로부터 이런 것들을 할당 받은 프로그램을 프로세스라고 부른다.
- 스레드 : 프로세스의 실행 단위이다. 같은 프로세스 내에 있는 스레드끼리는 프로세스의 자원을 공유할 수 있다.

### 프로세스(Process)

프로세스는 운영체제로부터 메모리 공간을 할당 받아 실행 중인 프로그램이다.

**프로세스에 할당되는 메모리 영역**

> 코드(Code), 데이터(Data), 힙(Heap), 스택(Stack) 영역

- **코드 영역** : 프로세스가 실행할 코드가 기계어의 형태로 저장된 공간이다.(컴파일 타임에 결정, Read-Only)
- **데이터 영역** : 전역 변수, static 변수 등이 저장된 공간이다. 전역 변수. static 변수를 참조한 코드는 컴파일하고 나면 데이터 영역의 주소 값을 가르킨다.(컴파일 타임에 결정, Read-Write: 실행 도중 변경 가능)
- **힙 영역** : 프로그래머가 관리하는 메모리 영역으로, 힙 영역에 메모리를 할당하는 것을 동적 할당이라고 한다.(런타임에 결정, 스택보다 할당할 수 있는 메모리 공간이 많으나 데이터 읽고 쓰기가 느림)
- **스택 영역** : 함수 안에서 선언된 지역변수, 매개변수, 리턴값, 복귀 주소 등이 저장된다. 스택의 LIFO 방식에 따라 함수 호출 시 기록하고 종료되면 제거한다. (컴파일 타임에 결정, 정해진 크기가 있으므로 stack overflow 에러 발생 가능)

프로세스 제어 블록 (Process Control Block, PCB)

- 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
- 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
- 프로그램 카운터 : 프로세스가 다음에 실핼할 명령어의 주소
- CPU 레지스터 : Accumulator, Index Register, 범용 레지스터 등
- CPU 스케줄링 정보 : 프로세스 우선순위, 최종 실행 시각, CPU 점유 시간 등
- 메모리 관리 정보 : Page table, Segment table 등
- 계정 정보 : CPU 사용 시간, 제한 시간, 계정 정보 등
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치, 개방된 파일 목록 등



### 스레드(Thread)

스레드는 프로세스를 구성하는 독립적인 실행 단위이다. 스레드는 같은 프로세스 내 다른 스레드와 메모리 영역을 공유 할 수 있다.

- 스레드도 하나의 실행 흐름이므로 실행과 관련된 데이터가 필요하다.
  - 독립적 : 각 스레드는 자신만의 고유한 **스레드ID, 프로그램 카운터(PC), 레지스터 집합, 스택 영역**을 가진다.
  - 공유 : 그리고 **속한 프로세스 내의 코드/데이터/힙 영역과 기타 운영체제 자원 (열린 파일, 신호 등)**을 다른 스레드와 공유한다.
- 각 스레드는 스택 영역을 통해 독립적인 실행 흐름을 가진다.
- 스레드는 프로세스 메모리 영역을 공유하기 때문에 어떤 스레드 하나에서 오류가 발생하면 같은 프로세스 내의 다른 스레드 모두가 강제로 종료된다. (프로세스는 한 프로세스가 강제 종료되어도 공유 자원을 손상시키는 경우가 아니라면 다른 프로세스에게 영향을 주지 않는다.)

**스택을 스레드마다 독립적으로 할당하는 이유**

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

**PC Register 를 스레드마다 독립적으로 할당하는 이유**

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 떄문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.

## 멀티 프로세스와 멀티 스레드

### 멀티 프로세스(Multi-Process)

여러 개의 프로세스를 동시에 수행하는 것이다.

> 프로세스는 부모-자식 관례라고 해도 자신만의 메모리 영역을 가지게 되며, 공유되는 메모리 영역 없이 독립적인 구조를 가진다.

**크롬 브라우저의 멀티 프로세스 구조**

대부분의 브라우저는 탭 브라우징을 지원한다. 만일 브라우저가 멀티 프로세스 구조를 가지지 않는다면, 어떤 탭의 웹 어플리케이션이 비정상 종료되었을 때 다른 모든 탭을 포함한 전체 프로세스가 종료될 것이다.

구글의 크롬 브라우저는 멀티 프로세스 구조를 가지고 있다. 브라우저의 각 탭은(Renderer) 프로세스이며, 이들은 각작 독립적으로 실행된다. 하나의 웹 사이트가 비정상 종료되어도 다른(Renderer) 프로세스는 영향을 받지 않는다.

크롬은 다음과 같은 3가지 유형의 프로세스르 지원한다.

- **브라우저 프로세스** : 사용자 인터페이스와 디스크 및 네트워크 I/O를 관리한다. 크롬이 시작되면 새 브라우저 프로세스가 생성된다.
- **Renderer 프로세스** : 웹 페이지 렌더링을 위한 로직(HTML, JavaScript, 이미지 등 처리)을 포함한다. 이 때, 새 탭에서 열리는 각 웹사이트에 대해 새 Renderer 프로세스가 생성되므로 여러 프로세스가 동시에 활성화 될 수 있다.
- **플러그인 프로세스** : Flash 또는 QuickTime과 같은 각 플러그인 유형에 대해 플러그인 프로세스가 생성된다. 플로그인 프로세스에는 플러그인에 대한 코드와 연관된 Renderer, 브라우저 프로세스와 통신할 수 있도록 하는 추가 코드가 포함되어 있다.

**멀티 프로세스의 통신 방법**

독립적인 메모리 영역을 가지는 프로세스끼리도 통신하는 방법이 있다. 데이터를 교환하기 위해서 IPC(Inter-Process Communication) 메커니즘이 필요하다. IPC에는 **공유 메모리(shared memory)**와 **메시지 전달(message passing)**의 두가지 모델이 있다.

- 공유 메모리 : 프로세스가 공유하는 메모리 영역이 설정되며, 각 프로세스는 공유 영역에서 데이터를 읽고 쓰는 방식으로 정보를 교환할 수 있다.
- 메시지 전달 : 프로세스 간 메시지를 교환하며 통신한다.

**멀티 프로세스의 장점**

- 독림된 구조를 가지기 때문에 안정성이 높다.
- 하나의 프로세스가 비정상적으로 종료되어도 자식 프로세스 이외의 다른 프로세스들은 아무런 영향을 받지 않는다.

**멀티 프로세스의 단점**

- 독립된 메모리 영역을 가지고 있기 때문에 Context Switching 을 위한 오버헤드(캐시 초기화 등)가 발생한다.
- Context Switching이 빈번하게 일어나면 성능 저하를 유발할 수 있다.



### 멀티 스레드(Multi-Thread)

한 프로세스에서 여러 개의 쓰레드를 동시에 수행하는 것이다.

![image-20210917224720688](C:\Users\multicampus\AppData\Roaming\Typora\typora-user-images\image-20210917224720688.png)

**멀티 스레드의 장점**

- **응답성**이 좋아진다. 단일 스레드를 사용하면 그 작업이 완료 될때까지 응답을 기다려야 한다. 멀티 스레드를 사용함으로서 응답성을 향상 시킬 수 있다.
- **자원을 공유**할 수 있다. 프로세스는 공유 메모리 및 메시지 전달과 같은 기술을 통해서만 자원을 공유할 수 있다.하지만 스레드는 기본적으로 자신이 속한 프로세스의 자원을 공유하기 때문에 동일한 주소 공간 내에서 여러 스레드를 가질 수 있다.
- **비용이 적다**. 스레드는 자신이 속한 프로세스의 자원을 공유하므로 스레드 생성과 Context-Switching 비용이 더 적다.

**멀티 스레드의 단점**

- 스레드는 프로세스 내 자원을 공유하기 때문에 스레드 하나에서 오류가 발생하면 같은 프로세스 내의 모든 스레드가 종료될 수 있다.
- 공유 자원에 대한 동기화 문제를 고려해야 한다.